# Using OIDC to Secure a SPA #

## Project setup ###
```
npm install
```

### Compiles and hot-reloads for development ###
```
npm run serve
```

# Project Learning Notes: Using OIDC to Secure a SPA #

Using a Vue.js frontend SPA and Keycloak as the Authentication Server. It’s configured to use the OIDC Authorisation Code Flow with PKCE - the standard for authenticating a public client. 

### Authorisation Code Flow Overview ###
It’s a sequence of requests between the `Client` and the `Authentication Server` which results in the `Client` receiving an `ID Token` and `Access Token`. It’s considered the most secure flow for a public Client, mitigating vulnerabilities of the Implicit Flow.

When the `User` completes login via the login page provided by the `Authentication Server`, the `Client` is presented with an `Authorisation Code` which can then be exchanged for an `ID Token` and `Access Token`. This is the main difference between the Implicit Flow and the Authorisation Code Flow. The additional round trip to the server means the exchange of the Authorisation Code for tokens can be done via a POST request. The request response body contains the tokens, this is considered safer than providing tokens to the client via a URI.

When tokens are issued during the Implicit Flow, they’re added to the URI on redirect from the `Authentication Server` to the `Client` after successful login. This means the token will be present in browser history and could be scanned and used by a malicious browser extension.

### PKCE ###
`PKCE` is an additional layer of security I used on top of the OIDC Authorisation Code Flow that mitigates issues with leaking tokens. The `PKCE` implementation produces a dynamic secret on the `Client` that mitigates the danger of having a fixed client secret in a public `Client`. 
The `Client` generates a random string known as the `code_verifier` which is hashed as a `code_challenge` using a `code_challenge_method`. The these values are talked about further in the step-by-step description of the flow below.

### A Further Look Into The Flow ###

![Alt text](./OIDC-flow-diagram.png?raw=true "OIDC Flow Diagram")

1. Request made pulls Vue.js Client into browser
2. A `code_verifier` value will be generated by the Client and hashed using the chosen `code_challenge_method` to produce a `code_challenge`
3. The `Client` makes a request to the `Authentication Servers` `/auth` endpoint

    Request URL example;
    ```
    http://{{HOST_NAME}}/auth/realms/quarkus/protocol/openid-connect/auth?
    client_id=frontend&
    redirect_uri=http%3A%2F%2Flocalhost%3A8080%2F&
    state={{STATE_STRING}}&
    response_mode=fragment&
    response_type=code&
    scope=openid&
    nonce={{NONCE_STRING}}&
    code_challenge={{CODE_CHALLENGE_SRING}}&
    code_challenge_method=S256
   ```
    
    Values passed as part of the request URL;
    * `client_id` - ID of the Client configured on the auth server
    * `redirect_uri` - URI to redirect to after successfully authenticated
    * `state` - additional CSRF protection
    * `response_type` - informs the auth server that we want an Authorisation Code in response
    * `scope` - informs the auth server that we want to do OIDC
    * `nonce` - it’s primary purpose is to mitigate replay attacks, it’s generated by the client and included in the ID Token in response
    * `code_challenge` - a dynamic string secret generated and hashed part of PKCE
    * `code_challenge_method` - sets the encryption method to produce the dynamic secret

4. `Client` makes a request to `/auth` which loads the Keycloak login page into the browser
5. `User` completes the login form, entering their credentials
6. `User` submits credentials which are then POSTed to the `Authentication Server`. (As the `Authentication Server` handles the login form and validation of credential the `Client` will never see the `User` credentials, this is the purpose of OAuth.)
7. The `Authentication Server` successfully verifies the credentials received and calls the `redirect_uri`. The Authorisation Code is passed to the `Client` via the URI, at this stage it's vulnerable to being intercepted. Although implementing `PKCE` means the risk of the attacker successfully exchanging the code for a token is reduced as the attacker would also need the `code_verifier` (generated by the `Client` in Step 2). 
8. Now the `Client` has the Authorisation Code - a POST request to `/token` is made to exchange it for an `ID Token`. The POST request body contains the following;

    ```
    code={{AUTHORISATION_CODE_STRING}}
    grant_type=authorization_code
    client_id=frontend
    redirect_uri=http%3A%2F%2Flocalhost%3A8080%2F
    code_verifier={{CODE_VERIFIER_STRING}}
    ```

    * code - Authorisation Code provided by the Auth Server to be exchanged for an ID Token
    * grant_type - the authentication flow being used
    * client_id - ID of the Client configured on the auth server
    * redirect_uri - the URI of the Client
    * code_verifier - the original dynamic string secret generated by the client pre-hashing  

9. The request to ‘/token’ is validated - the Authorisation Code and the `code_verifier` values are checked. If validation is successful the ID Token is returned in the response body to the POST request;
    ```
    {
    “access_token”: {{TOKEN}}
    “expires_in":60,
    “refresh_expires_in”:600,
    “refresh_token”: {{TOKEN}}
    “token_type":"bearer",
    “id_token”: {{TOKEN}},
    “not-before-policy”:1604945392,
    “session_state":"04a67d11-625c-454d-83cf-524c749c0e4c",
    "scope":"openid email profile”
    }
    ```

10. The Client will now have an Access Token, ID Token and Refresh Token meaning they’ll be able to access some Resource Server.

### Nonce ###
The Nonce helps protect against Authorisation Code replay attacks by forcing one time use of tokens. It’s generated by the Client along with a timestamp then stored by the Client before being sent to the Authentication Server on the initial request to `/auth`. The Nonce is included in the ID Token as a claim, when the token is decoded on completion of the Nonce will be validated. 
* If the Clients Nonce and the ID Tokens Nonce match and is not expired —> the Nonce is deleted from client storage and the user is allowed to interact with the application. 
* If the Nonce is expired —> the user is forced to login again - this can happen when the user takes too long to login. 
* If the Nonce does not exist —> it’s assumed it’s already been used then the interaction is treated as malicious.

This means if a bad actor intercepts the Authorisation Code and does token exchange, the Client application will check its local storage for a Nonce matching the one in the ID Token. This ID Token will of course contain a Nonce that’s not present in the bad actors Client storage resulting in the actor will be treated as malicious. Each token will have a new Nonce value generated in the same way.
A Nonce should only be valid for a small period of time, something similar to the expiry time configured for the Authorisation Code.

### State ###
The State is used as protection against CSRF, it’s a string value that’s generated by the Client and bound to its User Agent. It’s included in requests to the Authentication Server and added to the tokens. The State must be stored in the client to allow you to validation decoded tokens. If the Client State value that doesn't match its User Agents you can infer that you may be the target of an attack.

### What could be done differently? ###
If I had a Resource Server I would have implemented the flow differently, so the Access token doesn’t appear on the public Client. I would be able to do this using by instead utilising sessions. The Resource Server would perform token exchange and then manage sessions with the public Client from the token. This  Benefits of this would be that tokens contain a lot of information that is exposed on a public Client.